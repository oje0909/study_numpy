# 20201118 ~
# 목표: RNN(Recurrent Neural Network, 순환신경망) 구성
# http://aikorea.org/cs231n/python-numpy-tutorial/#numpy 참고함

# 넘파이 numpy 는 파이썬의 과학 컴퓨팅을 위한 기본 라이브러리이다.
# N차원 배열 객체가 numpy 의 핵심
# 동일한 자료형을 가지는 값들이 격자판 형태로 있는 것이 Numpy 배열
# 각각의 값들은 튜플 형태로 색인된다. (x, y)


import numpy as np


# 1. 배열 생성

a = np.array([1, 2, 3])     # rank 가 1인 배열 생성
print(type(a))      # <class 'numpy.ndarray'>
print(a.shape)      # (3,)  길이?
print(a[0], a[1], a[2])     # 출력 1,2,3
a[0] = 5        # 요소 변경
print(a)        # [5, 2, 3]

b = np.array([[1, 2, 3], [4, 5, 6]])        # rank 가 2인 배열 생성
print(b.shape)          # (2, 3)
print(b[0, 0], b[0, 1], b[1, 0])        # 1, 2, 4
print(b[0])     # [1, 2, 3]

# 중첩 리스트 사용 뿐 아니라 배열을 위한 다양한 함수 제공

c = np.zeros((2, 2))     # 모든 값이 0인 배열 생성
print(c)        # [[0. 0.] [0. 0.]]

d = np.ones((1, 2))
print(d)

e = np.full((2, 2), 7)
print(e)        # 모든 값이 특정 상수인 배열 생성

f = np.eye(2)       # 2*2 단위행렬 생성
# 단위행렬 : 선형대수학에서, 단위 행렬(영어: unit matrix) 또는 항등 행렬(영어: identity matrix)은 주대각선의 원소가 모두 1이며 나머지 원소는 모두 0인 정사각 행렬이다.
print(f)

g = np.random.random((2, 2))        # 임의의 값으로 채워진 배열 생성
print(g)                    # [[0.79143591 0.48628766] [0.52190778 0.27490416]]


# 2. 배열 인덱싱
# 슬라이싱, 인덱싱 가능
# create the following rank 2 array with shape (3, 4)
# [[1 2 3 4]
# [5 6 7 8]
# [9 10 11 12]]

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

# 슬라이싱을 사용하여 첫 두 행과 1열, 2열로 이루어진 부분배열을 만들어 봅시다.
# b 는 shape가 (2, 2)인 배열이 됩니다.
# [[2, 3]
# [6, 7]]
b = a[:2, 1:3]      # 첫 행과 두번째 행에서 1번 인덱스부터 3번 인덱스 전까지 (1번 2번) 만 꺼낸다.
print(b)

# 슬라이싱된 배열은 원본 배열과 같은 데이터를 참조합니다. 즉 슬라이싱된 배열을 수정하면, 원본 배열 역시 수정된다.
print(a[0, 1])  # 2
b[0, 0] = 77
print(a[0, 1])  # 77

# 정수를 이용한 인덱싱과 슬라이싱을 혼합하여 사용할 수 있습니다.
# 그러나 이렇게 할 경우, 기존의 배열보다 낮은 rank의 배열이 얻어진다.

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

# 배열의 중간 행에 접근하는 방법은 2가지가 있다. 
# 정수 인덱싱과 슬라이싱을 혼합하여 사용하면 낮은 rank의 배열이 생성되지만, (낮은 rank란?)
# 슬라이싱만 사용하면 원본 배열과 동일한 rank 의 배열이 생성됩니다.
row_r1 = a[1, :]        # 배열a의 두 번째 행을 rank가 1인 배열로 1중리스트
row_r2 = a[1:2, :]      # 배열a의 두 번째 행을 rank가 2인 배열로 2중리스트라는 의미
print(row_r1, row_r1.shape)     # 출력 "[5 6 7 8] (4, )"
print(row_r2, row_r2.shape)     # 출력 "[[5 6 7 8]] (1, 4)"

# 그러면 이런 배열은 말이 안되는건가? ㅇㅇ -> Numpy 배열은 동일한 자료형을 가지는 값들이 격자판 형태로 있는 것이기 때문에
# [[1, 2, 3],
# [4, 5, 6, 7],
# [8, 9, 10, 11, 12]]

# 행이 아닌 열의 경우에도 마찬가지
col_r1 = a[:, 1]        # 인덱싱 슬라이싱 혼합
col_r2 = a[:, 1:2]      # 슬라이싱만 사용
print(col_r1, col_r1.shape)
print(col_r2, col_r2.shape)

# 정수 배열 인덱싱
# Numpy 배열을 슬라이싱하면, 결과로 얻어지는 배열은 언제나 원본 배열의 부분 배열이다.
# 그러나 정수 배열 인덱싱을 한다면, 원본과 다른 배열을 만들 수 있습니다.
a = np.array([[1, 2], [3, 4], [5, 6]])      # (3, 2)

# 정수 배열 인덱싱의 예
# 반환되는 배열의 shape는 (3,)
print(a[[0, 1, 2], [0, 1, 0]])      # 출력 [1, 4, 5]
# 위에서 본 정수 배열 인덱싱 예제는 다음과 동일하다.
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))      # 출력 [1, 4, 5]

# 정수 배열 인덱싱을 사용할 때, 
# 원본 배열의 같은 요소를 재사용할 수 있다.
print(a[[0, 0], [1, 1]])        # 출력 [2, 2]
# 위 예제는 다음과 동일하다.
print(np.array([a[0, 1], a[0, 1]]))

# 정수 배열 인덱싱을 유용하게 사용하는 방법 중 하나는 행렬의 각 행에서 하나의 요소를 선택하거나 바꾸는 것이다.

# 요소를 선택할 새로운 배열 생성
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
print(a)

# 인덱스를 저장할 배열 생성
b = np.array([0, 2, 0, 1])
print(b)

# b에 저장된 인덱스를 이용해 각 행에서 하나의 요소를 선택한다.
print(a[np.arange(4), b])       # [ 1  6  7 11]     # a의 부분을 인덱싱?해서 꺼낸 것 ㄴ
print(np.arange(4))     # [0, 1, 2, 3]
# = a[[0, 1, 2, 3], [0, 2, 0, 1]]
# = np.array([a[0, 0], a[1, 2], a[2, 0], a[3, 1]])
# [1, 6, 7, 11]

# b에 저장된 인덱스를 이용해 각 행에서 하나의 요소를 변경한다.   # 하나씩 꺼내서 +10 해서 다시 제자리에 넣어둔 것
a[np.arange(4), b] += 10
print(a)        # ?
# [[11  2  3]
#  [ 4  5 16]
#  [17  8  9]
#  [10 21 12]]

# 불리언 배열 인덱싱
# 불리언 배열 인덱싱을 통해 배열 속 요소를 취사선택할 수 있습니다.
# 불리언 배열 인덱싱은 특정 조건을 만족하게 하는 요소만 선택하고자 할 때 자주 사용됩니다.

a = np.array([[1, 2], [3, 4], [5, 6]])

bool_idx = (a > 2)
print(type(bool_idx))       # <class 'numpy.ndarray'>
print(bool_idx)     # [[False False]
                    # [ True  True]
                    # [ True  True]]
# 2보다 큰 a의 요소를 찾습니다.
# 이 코드는 a와 shape가 같고 불리언 자료형을 요소로 하는 numpy 배열을 반환한다.
# bool_idx 의 각 요소는 동일한 위치에 있는 a의 요소가 2보다 큰지를 말해줍니다.

# 불리언 배열 인덱싱을 통해 bool_idx 에서
# 참 값을 가지는 요소로 구성되는
# rank 1인 배열을 구성할 수 있습니다.
print(a[bool_idx])      # [3 4 5 6]     왜 numpy.array 는 요소 사이사이에 list처럼 ,이 없을까?

# 위에서 한 모든 것을 한 문장으로 할 수 있습니다.
print(a[a > 2])     # [3 4 5 6]

# 추가로 더 알고 싶다면, 참고 문서로

























